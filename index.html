<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>SNAKE</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #0d1117;
            color: #c9d1d9;
            margin: 20px;
        }

        h1 {
            color: #00f080;
        }

        canvas {
            border: 5px solid #238636;
            background-color: #161b22;
            display: block;
            margin: 20px 0;
            box-shadow: 0 0 20px rgba(0, 240, 128, 0.4);
        }

        .game-status {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #c9d1d9;
        }

        button {
            padding: 12px 25px;
            margin-top: 15px;
            border: none;
            border-radius: 5px;
            background-color: #00f080;
            color: #161b22;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #009040;
            color: white;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            color: #888;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            color: #8b949e;
        }

        .high-score {
            color: #ffcc00;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        #game-over-message {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 2.2em;
            padding: 30px;
            border-radius: 15px;
            display: none;
            text-align: center;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            border: 3px solid red;
        }

        #final-score {
            font-size: 1.5em;
            color: #ffcc00;
        }
    </style>
</head>
<body>

<h1>üêç Le Serpent Classique</h1>

<div class="high-score">
    Meilleur Score: <span id="high-score">0</span>
</div>

<div class="game-status">
    Score: <span id="score">0</span> | Vitesse: <span id="speed-level">1</span>
</div>

<canvas id="snakeCanvas" width="400" height="400"></canvas>

<button id="start-button" onclick="startGame()">D√©marrer la Partie</button>

<div class="controls">
    üéÆ Utilisez les fl√®ches pour jouer
</div>

<div id="game-over-message">
    GAME OVER !<br>
    Score final : <span id="final-score">0</span>
</div>

<script>
    const CANVAS_SIZE = 400;
    const GRID_SIZE = 20;
    const TILE_SIZE = CANVAS_SIZE / GRID_SIZE;
    const INITIAL_SPEED = 150;
    const SPEED_INCREMENT = 3;
    const MIN_SPEED = 50;

    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const speedDisplay = document.getElementById('speed-level');
    const highScoreDisplay = document.getElementById('high-score');
    const gameOverMessage = document.getElementById('game-over-message');
    const startButton = document.getElementById('start-button');

    let snake = [];
    let food = {};
    let dx = TILE_SIZE;
    let dy = 0;
    let score = 0;
    let highScore = localStorage.getItem('snakeHighScore') || 0;
    let gameLoopInterval;
    let currentSpeed = INITIAL_SPEED;
    let isChangingDirection = false;
    let isGameRunning = false;
    let nextDirection = { dx: TILE_SIZE, dy: 0 };

    highScoreDisplay.textContent = highScore;

    function initGame() {
        snake = [
            { x: TILE_SIZE * 4, y: TILE_SIZE * 10 },
            { x: TILE_SIZE * 3, y: TILE_SIZE * 10 },
            { x: TILE_SIZE * 2, y: TILE_SIZE * 10 }
        ];
        dx = TILE_SIZE;
        dy = 0;
        nextDirection = { dx: TILE_SIZE, dy: 0 };
        score = 0;
        currentSpeed = INITIAL_SPEED;
        scoreDisplay.textContent = score;
        speedDisplay.textContent = 1;
        gameOverMessage.style.display = 'none';
        isChangingDirection = false;
        isGameRunning = false;
        startButton.disabled = false;
        startButton.textContent = 'D√©marrer la Partie';

        generateFood();

        document.removeEventListener('keydown', changeDirection);
        document.addEventListener('keydown', changeDirection);
        drawGame();
    }

    function startGame() {
        if (isGameRunning) {
            clearInterval(gameLoopInterval);
            initGame();
        }
        isGameRunning = true;
        startButton.disabled = true;
        startButton.textContent = 'Jeu en cours...';
        gameLoopInterval = setInterval(mainGameLoop, currentSpeed);
    }

    function mainGameLoop() {
        if (!isGameRunning) return;

        dx = nextDirection.dx;
        dy = nextDirection.dy;
        isChangingDirection = false;

        const head = { x: snake[0].x + dx, y: snake[0].y + dy };

        if (checkWallCollision(head) || checkSelfCollision(head)) {
            gameOver();
            return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
            score++;
            scoreDisplay.textContent = score;

            if (score > highScore) {
                highScore = score;
                highScoreDisplay.textContent = highScore;
                localStorage.setItem('snakeHighScore', highScore);
            }

            generateFood();
            increaseSpeed();
        } else {
            snake.pop();
        }

        drawGame();
    }

    function drawGame() {
        ctx.fillStyle = '#161b22';
        ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

        ctx.fillStyle = '#ff3333';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff3333';
        ctx.fillRect(food.x, food.y, TILE_SIZE, TILE_SIZE);
        ctx.shadowBlur = 0;

        snake.forEach((segment, index) => {
            if (index === 0) {
                ctx.fillStyle = '#00f080';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00f080';
            } else {
                const alpha = 1 - (index / snake.length) * 0.5;
                ctx.fillStyle = `rgba(35, 134, 54, ${alpha})`;
                ctx.shadowBlur = 0;
            }
            ctx.fillRect(segment.x + 1, segment.y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
        });
        ctx.shadowBlur = 0;
    }

    function generateFood() {
        let newFood;
        do {
            newFood = {
                x: Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE,
                y: Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE
            };
        } while (isFoodOnSnake(newFood));
        food = newFood;
    }

    function isFoodOnSnake(newFood) {
        return snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
    }

    function changeDirection(event) {
        if (isChangingDirection || !isGameRunning) return;

        const keyPressed = event.key.toLowerCase();

        const goingUp = dy === -TILE_SIZE;
        const goingDown = dy === TILE_SIZE;
        const goingRight = dx === TILE_SIZE;
        const goingLeft = dx === -TILE_SIZE;

        let newDx = nextDirection.dx;
        let newDy = nextDirection.dy;

        if ((keyPressed === 'arrowleft' || keyPressed === 'a') && !goingRight) {
            newDx = -TILE_SIZE; newDy = 0;
        } else if ((keyPressed === 'arrowup' || keyPressed === 'w') && !goingDown) {
            newDx = 0; newDy = -TILE_SIZE;
        } else if ((keyPressed === 'arrowright' || keyPressed === 'd') && !goingLeft) {
            newDx = TILE_SIZE; newDy = 0;
        } else if ((keyPressed === 'arrowdown' || keyPressed === 's') && !goingUp) {
            newDx = 0; newDy = TILE_SIZE;
        }

        if (newDx !== nextDirection.dx || newDy !== nextDirection.dy) {
            nextDirection.dx = newDx;
            nextDirection.dy = newDy;
            isChangingDirection = true;
        }

        if (keyPressed.startsWith('arrow')) {
            event.preventDefault();
        }
    }

    function checkWallCollision(head) {
        return (
            head.x < 0 ||
            head.x >= CANVAS_SIZE ||
            head.y < 0 ||
            head.y >= CANVAS_SIZE
        );
    }

    function checkSelfCollision(head) {
        for (let i = 0; i < snake.length; i++) {
            if (head.x === snake[i].x && head.y === snake[i].y) {
                return true;
            }
        }
        return false;
    }

    function increaseSpeed() {
        if (currentSpeed > MIN_SPEED) {
            currentSpeed -= SPEED_INCREMENT;
            const speedLevel = Math.floor((INITIAL_SPEED - currentSpeed) / SPEED_INCREMENT) + 1;
            speedDisplay.textContent = speedLevel;
        }
        clearInterval(gameLoopInterval);
        gameLoopInterval = setInterval(mainGameLoop, currentSpeed);
    }

    function gameOver() {
        isGameRunning = false;
        clearInterval(gameLoopInterval);
        document.getElementById('final-score').textContent = score;
        gameOverMessage.style.display = 'block';
        document.removeEventListener('keydown', changeDirection);
        startButton.disabled = false;
        startButton.textContent = 'Rejouer';
    }

    initGame();
</script>
</body>
</html>
